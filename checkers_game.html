<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Checkers Game with React</title>
  <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
  <style>
    body {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      margin: 0;
      padding: 20px;
      font-family: 'Arial', sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    .game-container {
      background: rgba(255, 255, 255, 0.95);
      border-radius: 20px;
      padding: 30px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      width: 75vw;
      max-width: 900px;
      min-height: 75vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .game-header {
      text-align: center;
      margin-bottom: 30px;
    }

    .game-title {
      font-size: 2.5em;
      color: #333;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
    }

    .game-title a {
      color: #667eea;
      text-decoration: none;
    }

    .game-title a:hover {
      color: #764ba2;
      text-decoration: none;
    }

    .board-container {
      display: flex;
      justify-content: center;
      margin: 20px 0;
    }

    .controls-container {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 15px;
      margin: 20px 0;
    }

    .btn {
      padding: 12px 24px;
      font-size: 1.1em;
      border-radius: 8px;
      border: none;
      transition: all 0.3s ease;
    }

    .btn-primary {
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
    }

    .btn-primary:hover {
      background: linear-gradient(45deg, #5a6fd8, #6a4190);
      transform: translateY(-2px);
    }

    .btn-info {
      background: linear-gradient(45deg, #17a2b8, #138496);
      color: white;
    }

    .btn-info:hover {
      background: linear-gradient(45deg, #138496, #117a8b);
      transform: translateY(-2px);
    }

    .progress {
      width: 100%;
      max-width: 500px;
      height: 30px;
      border-radius: 15px;
      margin: 20px 0;
      overflow: hidden;
      box-shadow: inset 0 3px 6px rgba(0,0,0,0.1);
    }

    .progress-bar {
      height: 100%;
      background: linear-gradient(45deg, #28a745, #20c997);
      border-radius: 15px;
      transition: width 0.6s ease;
    }

    .badge {
      font-size: 1em;
      padding: 8px 16px;
      border-radius: 20px;
      background: linear-gradient(45deg, #6c757d, #495057);
      color: white;
    }

    @keyframes shake {
      0% { transform: translate(1px, 1px) rotate(0deg); }
      10% { transform: translate(-1px, -2px) rotate(-1deg); }
      20% { transform: translate(-3px, 0px) rotate(1deg); }
      30% { transform: translate(3px, 2px) rotate(0deg); }
      40% { transform: translate(1px, -1px) rotate(1deg); }
      50% { transform: translate(-1px, 2px) rotate(-1deg); }
      60% { transform: translate(-3px, 1px) rotate(0deg); }
      70% { transform: translate(3px, 1px) rotate(-1deg); }
      80% { transform: translate(-1px, -1px) rotate(1deg); }
      90% { transform: translate(1px, 2px) rotate(0deg); }
      100% { transform: translate(1px, -2px) rotate(-1deg); }
    }

    #overlay {
      position: fixed;
      display: none;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 2000;
      cursor: pointer;
      background: rgba(0,0,0,0.5);
      backdrop-filter: blur(5px);
    }

    .modal-content {
      border-radius: 15px;
      border: none;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    }

    .modal-header {
      background: linear-gradient(45deg, #667eea, #764ba2);
      color: white;
      border-radius: 15px 15px 0 0;
    }

    .modal-title {
      font-size: 1.5em;
      font-weight: bold;
    }

    .modal-body {
      padding: 25px;
      font-size: 1.1em;
      line-height: 1.6;
    }

    .modal-body ul {
      padding-left: 20px;
    }

    .modal-body li {
      margin: 10px 0;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .game-container {
        width: 95vw;
        padding: 20px;
        min-height: 90vh;
      }

      .game-title {
        font-size: 2em;
      }

      .controls-container {
        flex-direction: column;
        align-items: center;
      }

      .btn {
        width: 200px;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div id="overlay"><img src="game_over.gif"></div>
    
    <div class="game-header">
      <h1 class="game-title">
        <a href="https://en.wikipedia.org/wiki/Draughts">üèÅ Checkers Game</a>
      </h1>
      <p style="color: #666; font-size: 1.2em;">Strategic board game with AI opponent</p>
    </div>

    <div class="board-container">
      <div id="root"></div>
    </div>

    <div class="controls-container">
      <button type="button" class="btn btn-primary" onclick="newGame(true)">
        <i class="fa fa-refresh"></i> New Game
      </button>
      
      <button type="button" class="btn btn-info" data-toggle="modal" data-target="#myModal">
        <i class="fa fa-info-circle"></i> Rules & Info
        <span class="badge" id="status-text">Your Turn (Red)</span>
      </button>
    </div>

    <div class="progress">
      <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="24" style="width: 0%" id="progress">
        <span class="badge" id="progress-text">Red Captured: 0 | Beige Captured: 0</span>
      </div>
    </div>

    <!-- Modal -->
    <div id="myModal" class="modal fade" role="dialog">
      <div class="modal-dialog modal-lg">
        <div class="modal-content">
          <div class="modal-header">
            <button type="button" class="close" data-dismiss="modal" style="color: white; opacity: 0.8;">&times;</button>
            <h4 class="modal-title">üèÅ Checkers Rules & How to Play</h4>
          </div>
          <div class="modal-body">
            <h5><strong>üéØ Objective:</strong></h5>
            <p>Capture all of your opponent's pieces to win the game!</p>
            
            <h5><strong>üéÆ How to Play:</strong></h5>
            <ul>
              <li><strong>Board:</strong> Played on an 8√ó8 checkered board using only the 32 dark squares</li>
              <li><strong>Players:</strong> You play as Red pieces, AI plays as Beige pieces</li>
              <li><strong>Movement:</strong> Click a piece, then click an empty dark square to move diagonally forward</li>
              <li><strong>Capturing:</strong> Jump over opponent pieces diagonally to capture them</li>
              <li><strong>Kings:</strong> Pieces reaching the opponent's back row become kings (shown with a crown ‚ôî)</li>
              <li><strong>King Powers:</strong> Kings can move both forward and backward diagonally</li>
              <li><strong>Winning:</strong> First player to capture all opponent pieces wins!</li>
            </ul>
            
            <h5><strong>üìä Game Stats:</strong></h5>
            <p>Track captured pieces in the progress bar below the board. The game ends when one player has captured all opponent pieces.</p>
          </div>
          <div class="modal-footer">
            <button type="button" class="btn btn-primary" data-dismiss="modal">
              <i class="fa fa-play"></i> Let's Play!
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script type="text/babel">
    let size = 8; // 8x8 board
    let board = [];
    let currentPlayer = 'red';
    let redCaptured = 0;
    let beigeCaptured = 0;
    let moveCount = 0;
    let gameOver = false;
    let updateCounter = 0; // Global counter to trigger re-renders
    let selectedPiece = null; // Tracks selected piece for moves

    function isDarkSquare(y, x) {
      return (y + x) % 2 === 1; // Dark squares have odd sum of coordinates
    }

    function newGame(redraw) {
      gameOver = false;
      currentPlayer = 'red';
      redCaptured = 0;
      beigeCaptured = 0;
      moveCount = 0;
      selectedPiece = null;
      updateCounter++;
      document.getElementById("progress").style.width = "0%";
      document.getElementById("progress-text").innerHTML = "Red Captured: 0 | Beige Captured: 0";
      document.getElementById("status-text").innerHTML = "Your Turn (Red)";
      document.getElementById("root").style.animation = '';
      document.getElementById("overlay").style.display = "none";

      board = Array(size).fill().map((_, y) =>
        Array(size).fill().map((_, x) => ({
          y, x, state: null
        }))
      );

      // Place Red pieces in rows 0-2, Beige pieces in rows 5-7 on dark squares
      for (let y = 0; y < 3; y++) {
        for (let x = 0; x < size; x++) {
          if (isDarkSquare(y, x)) {
            board[y][x].state = 'red';
          }
        }
      }
      for (let y = 5; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (isDarkSquare(y, x)) {
            board[y][x].state = 'beige';
          }
        }
      }

      if (redraw) {
        ReactDOM.render(<App size={size} updateCounter={updateCounter} />, document.getElementById('root'));
      }
    }

    function getValidMoves(y, x) {
      const piece = board[y][x].state;
      if (!piece) {
        return { moves: [], captures: [] };
      }
      
      // Fixed logic: Check if piece belongs to current player
      if ((piece.includes('red') && currentPlayer !== 'red') || 
          (piece.includes('beige') && currentPlayer !== 'beige')) {
        return { moves: [], captures: [] };
      }
      
      const isKing = piece.includes('king');
      const directions = piece.includes('red') ? 
        (isKing ? [[-1, -1], [-1, 1], [1, -1], [1, 1]] : [[1, -1], [1, 1]]) :
        (isKing ? [[-1, -1], [-1, 1], [1, -1], [1, 1]] : [[-1, -1], [-1, 1]]);
      const moves = [];
      const captures = [];

      // Check simple moves (one square diagonally)
      for (let [dy, dx] of directions) {
        let ny = y + dy;
        let nx = x + dx;
        if (ny >= 0 && ny < size && nx >= 0 && nx < size && isDarkSquare(ny, nx) && !board[ny][nx].state) {
          moves.push({ y: ny, x: nx });
        }
      }

      // Check capture moves (jump over opponent)
      for (let [dy, dx] of directions) {
        let ny = y + dy;
        let nx = x + dx;
        let jumpY = y + 2 * dy;
        let jumpX = x + 2 * dx;
        if (ny >= 0 && ny < size && nx >= 0 && nx < size && 
            jumpY >= 0 && jumpY < size && jumpX >= 0 && jumpX < size &&
            isDarkSquare(jumpY, jumpX) && !board[jumpY][jumpX].state) {
          const opponent = currentPlayer === 'red' ? 'beige' : 'red';
          if (board[ny][nx].state && board[ny][nx].state.includes(opponent)) {
            captures.push({ y: jumpY, x: jumpX, captureY: ny, captureX: nx });
          }
        }
      }

      return { moves, captures };
    }

    function movePiece(fromY, fromX, toY, toX, captureY, captureX) {
      const piece = board[fromY][fromX].state;
      board[toY][toX].state = piece;
      board[fromY][fromX].state = null;
      if (captureY !== undefined && captureX !== undefined) {
        board[captureY][captureX].state = null;
        if (currentPlayer === 'red') {
          beigeCaptured++;
        } else {
          redCaptured++;
        }
      }
      // Promote to king
      if (currentPlayer === 'red' && toY === size - 1 && !piece.includes('king')) {
        board[toY][toX].state = 'red-king';
      } else if (currentPlayer === 'beige' && toY === 0 && !piece.includes('king')) {
        board[toY][toX].state = 'beige-king';
      }
    }

    // New function to count remaining pieces
    function countPieces(player) {
      let count = 0;
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (board[y][x].state && board[y][x].state.includes(player)) {
            count++;
          }
        }
      }
      return count;
    }

    // Function to check if game should end (all opponent pieces captured)
    function checkGameEnd() {
      const redPieces = countPieces('red');
      const beigePieces = countPieces('beige');
      
      if (redPieces === 0) {
        endGame('üéâ Beige Wins! All Red pieces captured!');
        return true;
      } else if (beigePieces === 0) {
        endGame('üéâ Red Wins! All Beige pieces captured!');
        return true;
      }
      return false;
    }

    function placeMove(y, x) {
      if (gameOver) return;
      if (!selectedPiece) {
        if (board[y][x].state && board[y][x].state.includes('red') && currentPlayer === 'red') {
          selectedPiece = { y, x };
          updateCounter++;
          ReactDOM.render(<App size={size} updateCounter={updateCounter} />, document.getElementById('root'));
        }
        return;
      }

      const { moves, captures } = getValidMoves(selectedPiece.y, selectedPiece.x);
      const target = moves.find(m => m.y === y && m.x === x);
      const capture = captures.find(c => c.y === y && c.x === x);

      if (target || capture) {
        movePiece(selectedPiece.y, selectedPiece.x, y, x, capture?.captureY, capture?.captureX);
        selectedPiece = null;
        moveCount++;
        
        // Check if game ends due to all pieces captured
        if (checkGameEnd()) {
          return;
        }
        
        currentPlayer = 'beige';
        document.getElementById("status-text").innerHTML = "AI's Turn (Beige)";
        document.getElementById("progress-text").innerHTML = `Red Captured: ${redCaptured} | Beige Captured: ${beigeCaptured}`;
        updateCounter++;
        ReactDOM.render(<App size={size} updateCounter={updateCounter} />, document.getElementById('root'));
        setTimeout(aiMove, 1000); // AI moves after a 1-second delay
      } else {
        alert("‚ùå Invalid move: Choose a valid diagonal move or capture!");
        selectedPiece = null;
        updateCounter++;
        ReactDOM.render(<App size={size} updateCounter={updateCounter} />, document.getElementById('root'));
      }
    }

    function aiMove() {
      if (gameOver || currentPlayer !== 'beige') return;

      let captures = [];
      let moves = [];
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (board[y][x].state && board[y][x].state.includes('beige')) {
            const { moves: pieceMoves, captures: pieceCaptures } = getValidMoves(y, x);
            pieceCaptures.forEach(c => captures.push({ fromY: y, fromX: x, ...c }));
            pieceMoves.forEach(m => moves.push({ fromY: y, fromX: x, ...m }));
          }
        }
      }

      if (captures.length > 0) {
        // Prioritize captures
        const move = captures[Math.floor(Math.random() * captures.length)];
        movePiece(move.fromY, move.fromX, move.y, move.x, move.captureY, move.captureX);
      } else if (moves.length > 0) {
        // Prefer advancing moves (closer to row 0 for Beige)
        moves.sort((a, b) => a.y - b.y); // Lower y is closer to Beige's goal
        const move = moves[0];
        movePiece(move.fromY, move.fromX, move.y, move.x);
      } else {
        // This should not happen in normal gameplay since we only end on piece capture
        endGame('üéâ Red Wins! AI has no moves!');
        return;
      }

      moveCount++;
      
      // Check if game ends due to all pieces captured
      if (checkGameEnd()) {
        return;
      }
      
      currentPlayer = 'red';
      document.getElementById("status-text").innerHTML = "Your Turn (Red)";
      document.getElementById("progress-text").innerHTML = `Red Captured: ${redCaptured} | Beige Captured: ${beigeCaptured}`;
      updateCounter++;
      ReactDOM.render(<App size={size} updateCounter={updateCounter} />, document.getElementById('root'));
    }

    function endGame(message) {
      gameOver = true;
      document.getElementById("progress").style.width = "100%";
      document.getElementById("progress-text").innerHTML = `üèÅ Game Over! Red Captured: ${redCaptured} | Beige Captured: ${beigeCaptured}`;
      document.getElementById("status-text").innerHTML = message;
      document.getElementById("overlay").style.display = "block";
      setTimeout(() => document.getElementById("overlay").style.display = "none", 3000);
      document.getElementById("root").style.animation = 'shake 0.3s 1';
      updateCounter++;
      ReactDOM.render(<App size={size} updateCounter={updateCounter} />, document.getElementById('root'));
    }

    // Scaled up cell and piece sizes for better visibility
    const cellStyleLight = {
      width: '60px',
      height: '60px',
      backgroundColor: '#fff',
      margin: '2px',
      textAlign: 'center',
      display: 'inline-block',
      verticalAlign: 'top',
      position: 'relative',
      border: '1px solid #ddd'
    };

    const cellStyleDark = {
      width: '60px',
      height: '60px',
      backgroundColor: '#555',
      margin: '2px',
      borderRadius: '5px',
      textAlign: 'center',
      display: 'inline-block',
      verticalAlign: 'top',
      position: 'relative',
      border: '1px solid #333'
    };

    const pieceStyleRed = {
      width: '50px',
      height: '50px',
      backgroundColor: 'rgba(255, 0, 0, 0.8)',
      margin: '5px',
      borderRadius: '50%',
      border: '3px solid #8b0000',
      textAlign: 'center',
      display: 'block',
      position: 'absolute',
      top: '0',
      left: '0',
      cursor: 'pointer',
      transition: 'all 0.2s ease'
    };

    const pieceStyleBeige = {
      width: '50px',
      height: '50px',
      backgroundColor: 'rgba(245, 245, 220, 0.9)',
      margin: '5px',
      borderRadius: '50%',
      border: '3px solid #8b7d6b',
      textAlign: 'center',
      display: 'block',
      position: 'absolute',
      top: '0',
      left: '0',
      cursor: 'pointer',
      transition: 'all 0.2s ease'
    };

    const pieceStyleRedKing = {
      width: '50px',
      height: '50px',
      backgroundColor: 'rgba(255, 0, 0, 0.8)',
      margin: '5px',
      borderRadius: '50%',
      border: '3px solid #8b0000',
      textAlign: 'center',
      display: 'block',
      position: 'absolute',
      top: '0',
      left: '0',
      lineHeight: '44px',
      cursor: 'pointer',
      transition: 'all 0.2s ease'
    };

    const pieceStyleBeigeKing = {
      width: '50px',
      height: '50px',
      backgroundColor: 'rgba(245, 245, 220, 0.9)',
      margin: '5px',
      borderRadius: '50%',
      border: '3px solid #8b7d6b',
      textAlign: 'center',
      display: 'block',
      position: 'absolute',
      top: '0',
      left: '0',
      lineHeight: '44px',
      cursor: 'pointer',
      transition: 'all 0.2s ease'
    };

    const pieceStyleSelected = {
      width: '50px',
      height: '50px',
      backgroundColor: 'rgba(255, 215, 0, 0.9)',
      margin: '5px',
      borderRadius: '50%',
      border: '3px solid #8b6508',
      textAlign: 'center',
      display: 'block',
      position: 'absolute',
      top: '0',
      left: '0',
      lineHeight: '44px',
      cursor: 'pointer',
      transition: 'all 0.2s ease',
      boxShadow: '0 0 15px rgba(255, 215, 0, 0.6)'
    };

    const rStyle = { backgroundColor: 'transparent', display: 'block', textAlign: 'center' };
    const contStyle = { 
      backgroundColor: '#fff', 
      display: 'inline-block',
      border: '4px solid #333',
      borderRadius: '10px',
      padding: '5px',
      boxShadow: '0 10px 30px rgba(0,0,0,0.3)'
    };

    class ObjectCell extends React.Component {
      constructor(props) {
        super(props);
        this.state = { x: props.x, y: props.y };
        this.handleClick = this.handleClick.bind(this);
      }

      shouldComponentUpdate(nextProps) {
        return nextProps.updateCounter !== this.props.updateCounter;
      }

      handleClick(e) {
        e.preventDefault();
        if (e.type === 'click') {
          placeMove(this.state.y, this.state.x);
        }
      }

      render() {
        const { x, y } = this.state;
        const cell = board[y][x];
        const { state } = cell;
        const isSelected = selectedPiece && selectedPiece.y === y && selectedPiece.x === x;

        const cellStyle = isDarkSquare(y, x) ? cellStyleDark : cellStyleLight;
        let pieceStyle = null;
        let content = '\u00A0'; // Non-breaking space
        if (state === 'red') {
          pieceStyle = isSelected ? pieceStyleSelected : pieceStyleRed;
        } else if (state === 'beige') {
          pieceStyle = isSelected ? pieceStyleSelected : pieceStyleBeige;
        } else if (state === 'red-king') {
          pieceStyle = isSelected ? pieceStyleSelected : pieceStyleRedKing;
        } else if (state === 'beige-king') {
          pieceStyle = isSelected ? pieceStyleSelected : pieceStyleBeigeKing;
        }

        return (
          <div className="cell" style={cellStyle} onClick={isDarkSquare(y, x) ? this.handleClick : null}>
            {pieceStyle ? (
              <div style={pieceStyle}>
                {(state === 'red-king' || state === 'beige-king') ? (
                  <span style={{fontSize: '24px', color: '#FFD700', fontWeight: 'bold', textShadow: '1px 1px 2px rgba(0,0,0,0.5)'}}>‚ôî</span>
                ) : null}
              </div>
            ) : content}
          </div>
        );
      }
    }

    function ObjectRow(props) {
      const cells = Array.from({ length: props.size }, (_, j) => (
        <ObjectCell key={j} y={props.y} x={j} updateCounter={props.updateCounter} />
      ));
      return <div>{cells}</div>;
    }

    class App extends React.Component {
      render() {
        const rows = Array.from({ length: this.props.size }, (_, i) => (
          <div style={rStyle} key={i}>
            <ObjectRow y={i} size={this.props.size} updateCounter={this.props.updateCounter} />
          </div>
        ));
        return <div style={contStyle}>{rows}</div>;
      }
    }

    newGame();
    ReactDOM.render(<App size={size} updateCounter={updateCounter} />, document.getElementById('root'));
  </script>
</body>
</html>
