<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Tic-Tac-Toe Game with React</title>
  <script src="https://unpkg.com/react@16/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.4.1/js/bootstrap.min.js"></script>
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
  <style>
    @keyframes shake {
      0% { transform: translate(1px, 1px) rotate(0deg); }
      10% { transform: translate(-1px, -2px) rotate(-1deg); }
      20% { transform: translate(-3px, 0px) rotate(1deg); }
      30% { transform: translate(3px, 2px) rotate(0deg); }
      40% { transform: translate(1px, -1px) rotate(1deg); }
      50% { transform: translate(-1px, 2px) rotate(-1deg); }
      60% { transform: translate(-3px, 1px) rotate(0deg); }
      70% { transform: translate(3px, 1px) rotate(-1deg); }
      80% { transform: translate(-1px, -1px) rotate(1deg); }
      90% { transform: translate(1px, 2px) rotate(0deg); }
      100% { transform: translate(1px, -2px) rotate(-1deg); }
    }

    #overlay {
      position: fixed;
      display: none;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 2;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <div class="panel panel-default">
    <div id="overlay"><img src="game_over.gif"></div>
    <div class="panel-body" style="display: inline-block">
      <form class="form-inline">
        <fieldset>
          <legend>
            <a href="https://en.wikipedia.org/wiki/Tic-tac-toe">Tic-Tac-Toe Game</a> with React
          </legend>
          <div id="root"></div>
          <p></p>
          <div>
            <div class="form-group">
              <button type="button" class="btn btn-primary" onclick="newGame(true)">New Game</button>
            </div>
            <button type="button" class="btn btn-info" data-toggle="modal" data-target="#myModal">
              Info&nbsp;<span class="badge badge-light" id="status-text">Your Turn (X)</span>
            </button>
            <div id="myModal" class="modal fade" role="dialog">
              <div class="modal-dialog">
                <div class="modal-content">
                  <div class="modal-header">
                    <button type="button" class="close" data-dismiss="modal">&times;</button>
                    <h4 class="modal-title">Tic-Tac-Toe Rules</h4>
                  </div>
                  <div class="modal-body">
                    <ul>
                      <li>Played on a 3x3 grid.</li>
                      <li>You play as X, and the AI plays as O, taking turns.</li>
                      <li>Click an empty square to place your X.</li>
                      <li>Goal: Connect three of your symbols in a row, column, or diagonal before the AI.</li>
                      <li>The game ends with a win or a draw if the board is full.</li>
                      <li>Symbol counts are shown in the progress bar (X: X | O: Y).</li>
                    </ul>
                  </div>
                  <div class="modal-footer">
                    <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
                  </div>
                </div>
              </div>
            </div>
            <p></p>
            <div class="progress">
              <div class="progress-bar" role="progressbar" aria-valuenow="0" aria-valuemin="0" aria-valuemax="9" style="width: 0%" id="progress">
                <span class="badge badge-light" id="progress-text">X: 0 | O: 0</span>
              </div>
            </div>
          </div>
        </fieldset>
      </form>
    </div>
  </div>

  <script type="text/babel">
    let size = 3; // 3x3 board
    let board = [];
    let currentPlayer = 'x';
    let xCount = 0;
    let oCount = 0;
    let moveCount = 0;
    let gameOver = false;
    let updateCounter = 0; // Global counter to trigger re-renders

    function newGame(redraw) {
      gameOver = false;
      currentPlayer = 'x';
      xCount = 0;
      oCount = 0;
      moveCount = 0;
      updateCounter++;
      document.getElementById("progress").style.width = "0%";
      document.getElementById("progress-text").innerHTML = "X: 0 | O: 0";
      document.getElementById("status-text").innerHTML = "Your Turn (X)";
      document.getElementById("root").style.animation = '';
      document.getElementById("overlay").style.display = "none";

      board = Array(size).fill().map((_, y) =>
        Array(size).fill().map((_, x) => ({
          y, x, state: null
        }))
      );

      if (redraw) {
        ReactDOM.render(<App size={size} updateCounter={updateCounter} />, document.getElementById('root'));
      }
    }

    function checkWin(player) {
      // Check rows
      for (let y = 0; y < size; y++) {
        if (board[y][0].state === player && board[y][1].state === player && board[y][2].state === player) {
          return true;
        }
      }
      // Check columns
      for (let x = 0; x < size; x++) {
        if (board[0][x].state === player && board[1][x].state === player && board[2][x].state === player) {
          return true;
        }
      }
      // Check diagonals
      if (board[0][0].state === player && board[1][1].state === player && board[2][2].state === player) {
        return true;
      }
      if (board[0][2].state === player && board[1][1].state === player && board[2][0].state === player) {
        return true;
      }
      return false;
    }

    function placeSymbol(y, x, player) {
      if (gameOver || board[y][x].state) return false;
      board[y][x].state = player;
      if (player === 'x') {
        xCount++;
      } else {
        oCount++;
      }
      moveCount++;
      return true;
    }

    function placeMove(y, x) {
      if (currentPlayer !== 'x') return;
      if (!placeSymbol(y, x, 'x')) {
        alert("Invalid move: Cell is already occupied!");
        return;
      }
      if (checkWin('x')) {
        endGame('X Wins!');
        return;
      }
      if (moveCount === size * size) {
        endGame('Draw!');
        return;
      }
      currentPlayer = 'o';
      document.getElementById("status-text").innerHTML = "AI's Turn (O)";
      document.getElementById("progress-text").innerHTML = `X: ${xCount} | O: ${oCount}`;
      updateCounter++;
      ReactDOM.render(<App size={size} updateCounter={updateCounter} />, document.getElementById('root'));
      setTimeout(aiMove, 1000); // AI moves after a 1-second delay
    }

    function aiMove() {
      if (gameOver || currentPlayer !== 'o') return;

      // Try to win
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (!board[y][x].state) {
            board[y][x].state = 'o';
            if (checkWin('o')) {
              oCount++;
              moveCount++;
              endGame('O Wins!');
              document.getElementById("status-text").innerHTML = "O Wins!";
              document.getElementById("progress-text").innerHTML = `X: ${xCount} | O: ${oCount}`;
              updateCounter++;
              ReactDOM.render(<App size={size} updateCounter={updateCounter} />, document.getElementById('root'));
              return;
            }
            board[y][x].state = null; // Revert simulation
          }
        }
      }

      // Try to block
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (!board[y][x].state) {
            board[y][x].state = 'x';
            if (checkWin('x')) {
              board[y][x].state = 'o';
              oCount++;
              moveCount++;
              if (checkWin('o')) {
                endGame('O Wins!');
              } else if (moveCount === size * size) {
                endGame('Draw!');
              } else {
                currentPlayer = 'x';
                document.getElementById("status-text").innerHTML = "Your Turn (X)";
                document.getElementById("progress-text").innerHTML = `X: ${xCount} | O: ${oCount}`;
                updateCounter++;
                ReactDOM.render(<App size={size} updateCounter={updateCounter} />, document.getElementById('root'));
              }
              return;
            }
            board[y][x].state = null; // Revert simulation
          }
        }
      }

      // Random valid move
      let validMoves = [];
      for (let y = 0; y < size; y++) {
        for (let x = 0; x < size; x++) {
          if (!board[y][x].state) {
            validMoves.push({ y, x });
          }
        }
      }
      if (validMoves.length === 0) {
        endGame('Draw!');
        return;
      }
      const move = validMoves[Math.floor(Math.random() * validMoves.length)];
      board[move.y][move.x].state = 'o';
      oCount++;
      moveCount++;
      if (checkWin('o')) {
        endGame('O Wins!');
        return;
      }
      if (moveCount === size * size) {
        endGame('Draw!');
        return;
      }
      currentPlayer = 'x';
      document.getElementById("status-text").innerHTML = "Your Turn (X)";
      document.getElementById("progress-text").innerHTML = `X: ${xCount} | O: ${oCount}`;
      updateCounter++;
      ReactDOM.render(<App size={size} updateCounter={updateCounter} />, document.getElementById('root'));
    }

    function endGame(message) {
      gameOver = true;
      document.getElementById("progress").style.width = "100%";
      document.getElementById("progress-text").innerHTML = `Game Over! X: ${xCount} | O: ${oCount}`;
      document.getElementById("status-text").innerHTML = message;
      document.getElementById("overlay").style.display = "block";
      setTimeout(() => document.getElementById("overlay").style.display = "none", 2000);
      document.getElementById("root").style.animation = 'shake 0.3s 1';
      updateCounter++;
      ReactDOM.render(<App size={size} updateCounter={updateCounter} />, document.getElementById('root'));
    }

    const cellStyleEmpty = {
      width: '60px',
      height: '60px',
      backgroundColor: '#d3d3d3', // Light gray board
      margin: '2px',
      borderRadius: '5px',
      textAlign: 'center',
      display: 'inline-table',
      border: '1px solid #888',
      fontSize: '40px',
      lineHeight: '60px'
    };

    const cellStyleX = {
      width: '60px',
      height: '60px',
      backgroundColor: '#d3d3d3',
      margin: '2px',
      borderRadius: '5px',
      textAlign: 'center',
      display: 'inline-table',
      border: '1px solid #888',
      fontSize: '40px',
      lineHeight: '60px',
      color: 'blue'
    };

    const cellStyleO = {
      width: '60px',
      height: '60px',
      backgroundColor: '#d3d3d3',
      margin: '2px',
      borderRadius: '5px',
      textAlign: 'center',
      display: 'inline-table',
      border: '1px solid #888',
      fontSize: '40px',
      lineHeight: '60px',
      color: 'red'
    };

    const rStyle = { backgroundColor: '#d3d3d3', display: 'inline' };
    const contStyle = { backgroundColor: '#d3d3d3', display: 'inline' };

    class ObjectCell extends React.Component {
      constructor(props) {
        super(props);
        this.state = { x: props.x, y: props.y };
        this.handleClick = this.handleClick.bind(this);
      }

      shouldComponentUpdate(nextProps) {
        return nextProps.updateCounter !== this.props.updateCounter;
      }

      handleClick(e) {
        e.preventDefault();
        if (e.type === 'click') {
          placeMove(this.state.y, this.state.x);
        }
      }

      render() {
        const { x, y } = this.state;
        const cell = board[y][x];
        const { state } = cell;

        let style = cellStyleEmpty;
        let content = '\u00A0'; // Non-breaking space
        if (state === 'x') {
          style = cellStyleX;
          content = <i className="fa fa-times"></i>;
        } else if (state === 'o') {
          style = cellStyleO;
          content = <i className="fa fa-circle-o"></i>;
        }

        return (
          <div className="cell" style={style} onClick={this.handleClick}>
            {content}
          </div>
        );
      }
    }

    function ObjectRow(props) {
      const cells = Array.from({ length: props.size }, (_, j) => (
        <ObjectCell key={j} y={props.y} x={j} updateCounter={props.updateCounter} />
      ));
      return <div>{cells}</div>;
    }

    class App extends React.Component {
      render() {
        const rows = Array.from({ length: this.props.size }, (_, i) => (
          <div style={rStyle} key={i}>
            <ObjectRow y={i} size={this.props.size} updateCounter={this.props.updateCounter} />
          </div>
        ));
        return <div style={contStyle}>{rows}</div>;
      }
    }

    newGame();
    ReactDOM.render(<App size={size} updateCounter={updateCounter} />, document.getElementById('root'));
  </script>
</body>
</html>
